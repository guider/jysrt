{"version":3,"file":"subtitle.cjs.production.min.js","sources":["../src/utils.ts","../src/formatTimestamp.ts","../src/map.ts","../src/parseTimestamp.ts","../src/parseTimestamps.ts","../src/Formatter.ts","../src/Parser.ts","../src/filter.ts","../src/parse.ts","../src/parseSync.ts","../src/resync.ts","../src/stringify.ts","../src/stringifySync.ts"],"sourcesContent":["import { Duplex, DuplexOptions } from 'stream'\r\n\r\nexport const padLeft = (value: number, length = 2): string =>\r\n  value.toString().padStart(length, '0')\r\n\r\nexport const createDuplex = (options: DuplexOptions) =>\r\n  new Duplex({\r\n    objectMode: true,\r\n    autoDestroy: false,\r\n    read() {},\r\n    ...options\r\n  })\r\n","import { padLeft } from './utils'\r\nimport { FormatOptions } from '.'\r\n\r\nexport function formatTimestamp(\r\n  timestamp: number,\r\n  options: FormatOptions = { format: 'SRT' }\r\n) {\r\n  const date = new Date(0, 0, 0, 0, 0, 0, timestamp)\r\n\r\n  const hours = date.getHours()\r\n  const minutes = date.getMinutes()\r\n  const seconds = date.getSeconds()\r\n  const ms = timestamp - (hours * 3600000 + minutes * 60000 + seconds * 1000)\r\n\r\n  return `${padLeft(hours)}:${padLeft(minutes)}:${padLeft(seconds)}${\r\n    options.format === 'WebVTT' ? '.' : ','\r\n  }${padLeft(ms, 3)}`\r\n}\r\n","import { Transform } from 'stream'\r\nimport { Node } from '.'\r\n\r\nexport const map = (mapper: (node: Node, index: number) => any) => {\r\n  let index = 0\r\n\r\n  return new Transform({\r\n    objectMode: true,\r\n    autoDestroy: false,\r\n    transform(chunk: Node, _encoding, callback) {\r\n      callback(null, mapper(chunk, index++))\r\n    }\r\n  })\r\n}\r\n","export function parseTimestamp(timestamp: string): number {\n  const match = timestamp.match(/^(?:(\\d{1,}):)?(\\d{2}):(\\d{2})[,.](\\d{3})$/)\n\n  if (!match) {\n    throw new Error('Invalid SRT or VTT time format: \"' + timestamp + '\"')\n  }\n\n  const hours = match[1] ? parseInt(match[1], 10) * 3600000 : 0\n  const minutes = parseInt(match[2], 10) * 60000\n  const seconds = parseInt(match[3], 10) * 1000\n  const milliseconds = parseInt(match[4], 10)\n\n  return hours + minutes + seconds + milliseconds\n}\n","import { parseTimestamp, Timestamp } from '.'\r\n\r\nexport const RE_TIMESTAMP = /^((?:\\d{1,}:)?\\d{2}:\\d{2}[,.]\\d{3}) --> ((?:\\d{1,}:)?\\d{2}:\\d{2}[,.]\\d{3})(?: (.*))?$/\r\n\r\nexport function parseTimestamps(value: string): Timestamp {\r\n  const match = RE_TIMESTAMP.exec(value)\r\n\r\n  if (!match) {\r\n    throw new Error('Invalid timestamp format')\r\n  }\r\n\r\n  const timestamp: Timestamp = {\r\n    start: parseTimestamp(match[1]),\r\n    end: parseTimestamp(match[2])\r\n  }\r\n\r\n  if (match[3]) {\r\n    timestamp.settings = match[3]\r\n  }\r\n\r\n  return timestamp\r\n}\r\n","import { FormatOptions, Node, Cue, formatTimestamp } from '.'\r\n\r\nexport class Formatter {\r\n  private options: FormatOptions\r\n  private isVTT: boolean\r\n  private hasReceivedHeader: boolean\r\n  private index: number\r\n\r\n  constructor(options: FormatOptions) {\r\n    this.options = options\r\n    this.hasReceivedHeader = false\r\n    this.isVTT = options.format === 'WebVTT'\r\n    this.index = 1\r\n  }\r\n\r\n  public format(node: Node): string {\r\n    let buffer = ''\r\n\r\n    if (node.type === 'header' && this.isVTT) {\r\n      this.hasReceivedHeader = true\r\n      buffer += `${node.data}\\n\\n`\r\n    }\r\n\r\n    if (node.type === 'cue') {\r\n      if (!this.hasReceivedHeader && this.isVTT) {\r\n        this.hasReceivedHeader = true\r\n        buffer += 'WEBVTT\\n\\n'\r\n      }\r\n\r\n      buffer += this.formatCue(node.data, this.index++, this.options)\r\n    }\r\n\r\n    return buffer\r\n  }\r\n\r\n  private formatCue(cue: Cue, index: number, options: FormatOptions) {\r\n    return [\r\n      `${index > 1 ? '\\n' : ''}${index}`,\r\n      `${formatTimestamp(cue.start, options)} --> ${formatTimestamp(\r\n        cue.end,\r\n        options\r\n      )}${\r\n        options.format === 'WebVTT' && cue.settings ? ' ' + cue.settings : ''\r\n      }`,\r\n      cue.text,\r\n      ''\r\n    ].join('\\n')\r\n  }\r\n}\r\n","import stripBom from 'strip-bom'\r\nimport { Node, RE_TIMESTAMP, parseTimestamps } from '.'\r\n\r\nexport type Pusher = (node: Node) => void\r\n\r\nexport interface ParseState {\r\n  expect: 'header' | 'id' | 'timestamp' | 'text'\r\n  row: number\r\n  hasContentStarted: boolean\r\n  isWebVTT: boolean\r\n  node: Partial<Node>\r\n  buffer: string[]\r\n}\r\n\r\nexport class Parser {\r\n  private push: Pusher\r\n  private state: ParseState\r\n\r\n  constructor({ push }: { push: Pusher }) {\r\n    this.push = push\r\n    this.state = {\r\n      expect: 'header',\r\n      row: 0,\r\n      hasContentStarted: false,\r\n      isWebVTT: false,\r\n      node: {},\r\n      buffer: []\r\n    }\r\n  }\r\n\r\n  private isIndex(line: string): boolean {\r\n    return /^\\d+$/.test(line.trim())\r\n  }\r\n\r\n  private isTimestamp(line: string): boolean {\r\n    return RE_TIMESTAMP.test(line)\r\n  }\r\n\r\n  private getError(expected: string, index: number, row: string): Error {\r\n    return new Error(\r\n      `expected ${expected} at row ${index + 1}, but received: \"${row}\"`\r\n    )\r\n  }\r\n\r\n  public parseLine(line: string): void {\r\n    const contents = this.state.row === 0 ? stripBom(line) : line\r\n\r\n    if (!this.state.hasContentStarted) {\r\n      if (contents.trim()) {\r\n        this.state.hasContentStarted = true\r\n      } else {\r\n        return\r\n      }\r\n    }\r\n\r\n    const parse = {\r\n      header: this.parseHeader,\r\n      id: this.parseId,\r\n      timestamp: this.parseTimestamp,\r\n      text: this.parseText\r\n    }[this.state.expect]\r\n\r\n    parse.call(this, contents)\r\n\r\n    this.state.row++\r\n  }\r\n\r\n  public flush(): void {\r\n    if (this.state.buffer.length > 0) {\r\n      this.pushNode()\r\n    }\r\n  }\r\n\r\n  private parseHeader(line: string) {\r\n    if (!this.state.isWebVTT) {\r\n      this.state.isWebVTT = /^WEBVTT/.test(line)\r\n\r\n      if (this.state.isWebVTT) {\r\n        this.state.node.type = 'header'\r\n      } else {\r\n        this.parseId(line)\r\n        return\r\n      }\r\n    }\r\n\r\n    this.state.buffer.push(line)\r\n\r\n    if (!line) {\r\n      this.state.expect = 'id'\r\n      return\r\n    }\r\n  }\r\n\r\n  private parseId(line: string) {\r\n    this.state.expect = 'timestamp'\r\n\r\n    if (this.state.node.type === 'header') {\r\n      this.pushNode()\r\n    }\r\n\r\n    if (!this.isIndex(line)) {\r\n      this.parseTimestamp(line)\r\n    }\r\n  }\r\n\r\n  private parseTimestamp(line: string) {\r\n    if (!this.isTimestamp(line)) {\r\n      throw this.getError('timestamp', this.state.row, line)\r\n    }\r\n\r\n    this.state.node = {\r\n      type: 'cue',\r\n      data: {\r\n        ...parseTimestamps(line),\r\n        text: ''\r\n      }\r\n    }\r\n\r\n    this.state.expect = 'text'\r\n  }\r\n\r\n  private parseText(line: string) {\r\n    if (this.state.buffer.length > 0 && this.isTimestamp(line)) {\r\n      const lastIndex = this.state.buffer.length - 1\r\n\r\n      if (this.isIndex(this.state.buffer[lastIndex])) {\r\n        this.state.buffer.pop()\r\n      }\r\n\r\n      this.pushNode()\r\n      this.parseTimestamp(line)\r\n    } else {\r\n      this.state.buffer.push(line)\r\n    }\r\n  }\r\n\r\n  private pushNode(): void {\r\n    if (this.state.node.type === 'cue') {\r\n      while (true) {\r\n        const lastItem = this.state.buffer[this.state.buffer.length - 1]\r\n        if (['', '\\n'].includes(lastItem)) {\r\n          this.state.buffer.pop()\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n\r\n      while (true) {\r\n        const firstItem = this.state.buffer[0]\r\n        if (['', '\\n'].includes(firstItem)) {\r\n          this.state.buffer.shift()\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n\r\n      this.state.node.data!.text = this.state.buffer.join('\\n')\r\n    }\r\n\r\n    if (this.state.node.type === 'header') {\r\n      this.state.node.data = this.state.buffer.join('\\n').trim()\r\n    }\r\n\r\n    this.push(this.state.node as Node)\r\n\r\n    this.state.node = {}\r\n    this.state.buffer = []\r\n  }\r\n}\r\n","import { Node } from '.'\r\nimport { createDuplex } from './utils'\r\n\r\nexport const filter = (callback: (node: Node) => boolean) =>\r\n  createDuplex({\r\n    write(chunk, _encoding, next) {\r\n      if (callback(chunk)) {\r\n        this.push(chunk)\r\n      }\r\n      next()\r\n    }\r\n  })\r\n","import multipipe from 'multipipe'\r\nimport split2 from 'split2'\r\nimport { createDuplex } from './utils'\r\nimport { Parser } from './Parser'\r\n\r\nexport const parse = () => {\r\n  const parser = new Parser({\r\n    push: node => outputStream.push(node)\r\n  })\r\n\r\n  const stream = createDuplex({\r\n    write(chunk, _encoding, next) {\r\n      try {\r\n        parser.parseLine(chunk.toString())\r\n      } catch (err) {\r\n        return next(err)\r\n      }\r\n\r\n      next()\r\n    }\r\n  })\r\n\r\n  const splitStream = split2()\r\n\r\n  splitStream.on('finish', () => {\r\n    parser.flush()\r\n    stream.push(null)\r\n  })\r\n\r\n  const outputStream = multipipe(splitStream, stream, {\r\n    objectMode: true\r\n  })\r\n\r\n  return outputStream\r\n}\r\n","import { Parser } from './Parser'\r\nimport { NodeList } from '.'\r\n\r\nexport const parseSync = (input: string): NodeList => {\r\n  const buffer: NodeList = []\r\n  const parser = new Parser({\r\n    push: node => buffer.push(node)\r\n  })\r\n\r\n  input\r\n    .replace(/\\r\\n/g, '\\n')\r\n    .split('\\n')\r\n    .forEach(line => parser.parseLine(line))\r\n\r\n  parser.flush()\r\n\r\n  return buffer\r\n}\r\n","import { map, Node } from '.'\r\n\r\nexport const resync = (time: number) =>\r\n  map((node: Node) => {\r\n    if (node.type === 'cue') {\r\n      return {\r\n        ...node,\r\n        data: {\r\n          ...node.data,\r\n          start: node.data.start + time,\r\n          end: node.data.end + time\r\n        }\r\n      }\r\n    }\r\n\r\n    return node\r\n  })\r\n","import { map, FormatOptions, Node } from '.'\r\nimport { Formatter } from './Formatter'\r\n\r\nexport const stringify = (options: FormatOptions) => {\r\n  const formatter = new Formatter(options)\r\n  return map((chunk: Node) => formatter.format(chunk))\r\n}\r\n","import { NodeList, FormatOptions } from '.'\r\nimport { Formatter } from './Formatter'\r\n\r\nexport const stringifySync = (\r\n  list: NodeList,\r\n  options: FormatOptions\r\n): string => {\r\n  const formatter = new Formatter(options)\r\n\r\n  return list.reduce((buffer, node) => {\r\n    return buffer + formatter.format(node)\r\n  }, '')\r\n}\r\n"],"names":["padLeft","value","length","toString","padStart","createDuplex","options","Duplex","objectMode","autoDestroy","read","formatTimestamp","timestamp","format","date","Date","hours","getHours","minutes","getMinutes","seconds","getSeconds","ms","map","mapper","index","Transform","transform","chunk","_encoding","callback","parseTimestamp","match","Error","parseInt","RE_TIMESTAMP","parseTimestamps","exec","start","end","settings","Formatter","hasReceivedHeader","isVTT","node","buffer","type","this","data","formatCue","cue","text","join","Parser","push","state","expect","row","hasContentStarted","isWebVTT","isIndex","line","test","trim","isTimestamp","getError","expected","parseLine","contents","stripBom","header","parseHeader","id","parseId","parseText","call","flush","pushNode","pop","includes","shift","write","next","parser","outputStream","stream","err","splitStream","split2","on","multipipe","input","replace","split","forEach","time","formatter","list","reduce"],"mappings":"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"}